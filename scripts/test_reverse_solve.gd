extends Node

## Simple test to demonstrate reverse-solving workflow
## Run this scene to see how a level is generated from a goal state
## NOTE: Only runs in debug builds to avoid production issues

func _ready() -> void:
	if not OS.is_debug_build():
		return  # Don't run tests in production builds
	
	print("\n=== Reverse-Solving Workflow Demo ===\n")

	# Create Level 1 to demonstrate reverse-solving
	var level: LevelData = LevelData.create_level(1)

	print("Level: %s (ID: %d)" % [level.level_name, level.level_id])
	print("Move limit: %d" % level.move_limit)
	print("Target score: %d\n" % level.target_score)

	# Show the starting state (generated by reverse-solving)
	print("STARTING STATE (what player sees):")
	level.print_grid(level.starting_grid)

	# Show the solution
	print("\nSOLUTION MOVES:")
	for i in range(level.solution_moves.size()):
		var move: Dictionary = level.solution_moves[i]
		print("  Move %d: (%d,%d) <-> (%d,%d)" % [
			i + 1,
			move["from"].x, move["from"].y,
			move["to"].x, move["to"].y
		])

	# Simulate playing the solution forward
	print("\nSIMULATING SOLUTION:")
	var simulation_grid := LevelData._copy_grid(level.starting_grid)

	for i in range(level.solution_moves.size()):
		var move: Dictionary = level.solution_moves[i]
		print("\nAfter move %d:" % (i + 1))
		LevelData._swap_cells(simulation_grid, move["from"], move["to"])
		_print_simple_grid(simulation_grid)

	print("\n=== Demo Complete ===")

## Simple grid printer without the class instance
func _print_simple_grid(grid: Array) -> void:
	for y in range(grid.size()):
		var row_str := "  "
		for x in range(grid[y].size()):
			var color_id: int = grid[y][x]
			if color_id < 0:
				row_str += ". "
			else:
				row_str += str(color_id) + " "
		print(row_str)
